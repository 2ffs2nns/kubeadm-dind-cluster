#!/bin/bash

# Copyright 2013-2016 Jérôme Petazzoni, Johan Haleby, lalyos, James Harris,
#                     Michael Elsdörfer, Tony Hesjevik, Esben Haabendal,
#                     Michael A. Smith, Stefan Schimanski, Karl Isenberg,
#                     Alexander Morozov, David Calavera, Sven Dowideit,
#                     Tianon Gravi, Maru Newby
#
# Original sources: https://github.com/jpetazzo/dind
#                   https://github.com/docker/docker/blob/master/hack/dind
#                   https://github.com/marun/dkr-systemd-dind
# Modified to add docker network reservations.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

set -o errexit
set -o nounset
set -o pipefail

# Ensure that all nodes in /dev/mapper correspond to mapped devices currently loaded by the device-mapper kernel driver
dmsetup mknodes

if [ -d /sys/kernel/security ] && ! mountpoint -q /sys/kernel/security; then
  mount -t securityfs none /sys/kernel/security || {
    echo >&2 'Could not mount /sys/kernel/security.'
    echo >&2 'AppArmor detection and --privileged mode might break.'
  }
fi

# Ensure shared mount propagation to ensure volume mounting works for
# Kubernetes and OpenShift.
mount --make-shared /

# Mount /tmp (conditionally)
if ! mountpoint -q /tmp; then
  mount -t tmpfs none /tmp
fi

# find supported filesystem to use for docker image mounts
if grep -q overlay /proc/filesystems; then
  STORAGE_FS=overlay2
elif grep -q aufs /proc/filesystems; then
  STORAGE_FS=aufs
else
  echo "No supported filesystem found (aufs, overlay)"
  exit 1
fi

# find filesystem below /var/lib/docker
STORAGE_DIR="/var/lib/docker/$(hostname)"
mkdir -p "${STORAGE_DIR}"

# Smoke test the overlay filesystem:
# 1. create smoke dir in the storage dir being mounted (possibly on an overlay fs)
# 2. try to mount an overlay fs on top of the smoke dir
# 3. try to write a file in the overlay mount
# 4. if that succeeds set OVERLAY_WORKS=true
#
# Rational: There are kernels with broken overlay-over-overlay support (4.2 and
# probably 3.19). On those it's possible to mount an overlay in an overlay, but
# writing to a file results in a "No device" error.
OVERLAY_WORKS=true
if [ "${STORAGE_FS}" = "overlay2" ]; then
  D="${STORAGE_DIR}/smoke"
  mkdir -p "${D}/upper" "${D}/lower" "${D}/work" "${D}/mount"

  mount -t overlay overlay -o"lowerdir=${D}/lower,upperdir=${D}/upper,workdir=${D}/work" "${D}/mount" &&
  echo foo > "${D}/mount/probe" || OVERLAY_WORKS=false

  umount -f "${D}/mount" || true
  rm -rf "${D}" || true
fi

# If another filesystem than overlay is used or overlay does not work, create
# an ext3 loop device as an intermediary layer. The max size of the loop device
# is $VAR_LIB_DOCKER_SIZE in GB (default=5).
if [ "${STORAGE_FS}" != "overlay2" -o "${OVERLAY_WORKS}" == false ]; then
  STORAGE_FILE="/data/docker"
  VAR_LIB_DOCKER_SIZE=${VAR_LIB_DOCKER_SIZE:-5}
  mkdir -p "$(dirname "${STORAGE_FILE}")"
  if [ ! -f "${STORAGE_FILE}" ]; then
    dd if=/dev/zero of="${STORAGE_FILE}" bs=1G seek=${VAR_LIB_DOCKER_SIZE} count=0
    echo y | mkfs.ext3 "${STORAGE_FILE}"
  fi
  mount -o loop "${STORAGE_FILE}" "${STORAGE_DIR}"
fi

# bind mount it back to /var/lib/docker
mount -o bind "${STORAGE_DIR}" /var/lib/docker

export DOCKER_DAEMON_ARGS="${DOCKER_DAEMON_ARGS:-} --storage-driver=${STORAGE_FS} --log-driver=json-file"

docker_net_opts=""

# Bridge the containerized docker network to the host docker network.
# To enable this bridge, specify an IP offset for this container to use.
# Other containers on the same host should have different offsets
# such that the IPs within the range (offset <-> offset + size - 1) do not overlap.
if [ ! -z "${DOCKER_NETWORK_OFFSET:-}" ]; then
  # create docker0 bridge manually and attach it to the veth interface eth0
  brctl addbr docker0
  brctl addif docker0 eth0
  ip link set docker0 up

  # move ip to the bridge and restore routing via the old gateway
  IP_CIDR=$(ip addr show eth0 | grep -w inet | awk '{ print $2; }')
  IP=$(echo $IP_CIDR | sed 's,/.*,,')
  NETWORK_SIZE=$(echo $IP_CIDR | sed 's,.*/,,')
  DEFAULT_ROUTE=$(ip route | grep default | sed 's/eth0/docker0/')

  ip addr del $IP_CIDR dev eth0
  ip addr add $IP_CIDR dev docker0
  ip route add $DEFAULT_ROUTE

  # compute a network for the containers to live in
  # by adding DOCKER_NETWORK_OFFSET to the current IP and cutting off
  # non-network bits according to DOCKER_NETWORK_SIZE
  DOCKER_NETWORK_SIZE=${DOCKER_NETWORK_SIZE:-24}
  NETWORK=$(ip route | grep docker0 | grep -v default | sed 's,/.*,,')

  IFS=. read -r i1 i2 i3 i4 <<< $IP
  IFS=. read -r n1 n2 n3 n4 <<< $NETWORK
  IFS=. read -r o1 o2 o3 o4 <<< $DOCKER_NETWORK_OFFSET
  IFS=. read -r w1 w2 w3 w4 <<< $(ipcalc $IP_CIDR | grep Wildcard | awk '{print $2;}')

  IP_PLUS_OFFSET=$(printf "%d.%d.%d.%d\n" \
    "$(( n1 + ((i1 - n1 + o1) & w1) ))" \
    "$(( n2 + ((i2 - n2 + o2) & w2) ))" \
    "$(( n3 + ((i3 - n3 + o3) & w3) ))" \
    "$(( n4 + ((i4 - n4 + o4) & w4) ))")

  FIXED_CIDR=$(ipcalc $IP_PLUS_OFFSET/$DOCKER_NETWORK_SIZE | grep Network | awk '{print $2;}')
  echo "Using network $FIXED_CIDR for docker containers"

  # let docker reuse the given IP. If you run more than one dind slave, add
  # --fixed-cidr=a.b.c.d/24 to DOCKER_DAEMON_ARGS with disjunct networks.
  docker_net_opts="${docker_net_opts} --bip=${IP_CIDR} --fixed-cidr=${FIXED_CIDR}"
  export DOCKER_DAEMON_ARGS="${DOCKER_DAEMON_ARGS} --bip=${IP_CIDR} --fixed-cidr=${FIXED_CIDR}"

  # delete incompatible network settings
  rm -rf "/var/lib/docker/network"
fi

# FIXME: the following should be in systemd image
if [[ "${docker_net_opts}" ]]; then
  # only do this when starting the actual cluster and not during initial image preparation

  # FIXME: pass other options to docker started via systemd, too
  if [ -f /lib/systemd/system/docker.service ]; then
    sed -i "s@\(ExecStart=.*\)@\1 ${docker_net_opts}@" /lib/systemd/system/docker.service
  fi

  # FIXME: the following should be in systemd image
  # This ensures that node names are IPs so we don't need dnsmasq
  # FIXME: put proper dns / domain from config.sh there (KUBELET_DNS_ARGS)
  if [ -f /etc/systemd/system/kubelet.service.d/10-kubeadm.conf ]; then
    hostname_override="$(getent hosts $(hostname) | cut -d' ' -f1 | sort -u | tail -1)"
    sed -i "s@\(KUBELET_EXTRA_ARGS=\)@\1--hostname-override=${hostname_override} @" \
        /etc/systemd/system/kubelet.service.d/10-kubeadm.conf
  fi
fi

exec "$@"
