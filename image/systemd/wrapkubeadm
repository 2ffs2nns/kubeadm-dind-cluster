#!/bin/bash

set -o errexit
set -o nounset
set -o pipefail
set -o errtrace

docker_net_opts=""

# Bridge the containerized docker network to the host docker network.
# To enable this bridge, specify an IP offset for this container to use.
# Other containers on the same host should have different offsets
# such that the IPs within the range (offset <-> offset + size - 1) do not overlap.
if [ ! -z "${DOCKER_NETWORK_OFFSET:-}" ]; then
  # create docker0 bridge manually and attach it to the veth interface eth0
  brctl addbr docker0
  brctl addif docker0 eth0
  ip link set docker0 up

  # move ip to the bridge and restore routing via the old gateway
  IP_CIDR=$(ip addr show eth0 | grep -w inet | awk '{ print $2; }')
  IP=$(echo $IP_CIDR | sed 's,/.*,,')
  NETWORK_SIZE=$(echo $IP_CIDR | sed 's,.*/,,')
  DEFAULT_ROUTE=$(ip route | grep default | sed 's/eth0/docker0/')

  ip addr del $IP_CIDR dev eth0
  ip addr add $IP_CIDR dev docker0
  ip route add $DEFAULT_ROUTE

  # compute a network for the containers to live in
  # by adding DOCKER_NETWORK_OFFSET to the current IP and cutting off
  # non-network bits according to DOCKER_NETWORK_SIZE
  DOCKER_NETWORK_SIZE=${DOCKER_NETWORK_SIZE:-24}
  NETWORK=$(ip route | grep docker0 | grep -v default | sed 's,/.*,,')

  IFS=. read -r i1 i2 i3 i4 <<< $IP
  IFS=. read -r n1 n2 n3 n4 <<< $NETWORK
  IFS=. read -r o1 o2 o3 o4 <<< $DOCKER_NETWORK_OFFSET
  IFS=. read -r w1 w2 w3 w4 <<< $(ipcalc $IP_CIDR | grep Wildcard | awk '{print $2;}')

  IP_PLUS_OFFSET=$(printf "%d.%d.%d.%d\n" \
    "$(( n1 + ((i1 - n1 + o1) & w1) ))" \
    "$(( n2 + ((i2 - n2 + o2) & w2) ))" \
    "$(( n3 + ((i3 - n3 + o3) & w3) ))" \
    "$(( n4 + ((i4 - n4 + o4) & w4) ))")

  FIXED_CIDR=$(ipcalc $IP_PLUS_OFFSET/$DOCKER_NETWORK_SIZE | grep Network | awk '{print $2;}')
  echo "Using network $FIXED_CIDR for docker containers"

  # let docker reuse the given IP. If you run more than one dind slave, add
  # --fixed-cidr=a.b.c.d/24 to docker options with disjunct networks.
  docker_net_opts="${docker_net_opts} --bip=${IP_CIDR} --fixed-cidr=${FIXED_CIDR}"

  # delete incompatible network settings
  rm -rf "/var/lib/docker/network"
fi

if [[ "${docker_net_opts}" ]]; then
  # only do this when starting the actual cluster and not during initial image preparation

  if [ -f /lib/systemd/system/docker.service ]; then
    sed -i "s@\(ExecStart=.*\)@\1 ${docker_net_opts}@" /lib/systemd/system/docker.service
  fi

  # This ensures that node names are IPs so we don't need dnsmasq
  # FIXME: put proper dns / domain from config.sh there (KUBELET_DNS_ARGS)
  kubeadm_kubelet_conf=/etc/systemd/system/kubelet.service.d/10-kubeadm.conf
  if [ -f "${kubeadm_kubelet_conf}" ] && ! grep hostname-override "${kubeadm_kubelet_conf}"; then
    hostname_override="$(getent hosts $(hostname) | cut -d' ' -f1 | sort -u | tail -1)"
    sed -i "s@\(KUBELET_EXTRA_ARGS=\)@\1--hostname-override=${hostname_override} @" \
        "${kubeadm_kubelet_conf}"
  fi
fi

/usr/local/bin/start_services docker kubelet

# start kubeadm init
# FIXME: --hostname-override / --cluster-cidr are already obtained
# in wrapdocker for kubelet config
hostname_override="$(getent hosts $(hostname) | cut -d' ' -f1 | sort -u | tail -1)"
cluster_cidr="$(ip addr show docker0 | grep -w inet | awk '{ print $2; }')"
# --hostname-override=${hostname_override}
# makes no sense because it would be passed to every pod :(
# perhaps should just put all nodes into /etc/hosts on each node(?)
KUBE_HYPERKUBE_IMAGE=${HYPERKUBE_IMAGE} \
  kubeadm "$@"
